## 1.1 Recursively Specified Data

> 递归规范数据


When writing code for a procedure, we must know precisely what kinds of values may occur as arguments to the procedure, and what kinds of values are legal for the procedure to return. Often these sets of values are complex. In this section we introduce formal techniques for specifying sets of values.

> 在编写过程代码时，我们必须准确地知道哪些类型的值可能作为过程的参数出现，以及返回哪些类型的值是合法的。通常这些值集是复杂的。在本节中，我们将介绍用于规范值集的形式化技术。


### 1.1.1 Inductive Specification

> 归纳规范


*Inductive specification* is a powerful method of specifying a set of values. To illustrate this method, we use it to describe a certain subset S of the natural numbers $N = {0, 1, 2, ... }.$

> 归纳规范是规范一组值集的强大方法。为了说明这个方法，我们用它来描述自然数 $N = {0,1,2,... }$ 的某个子集 S 。


**Definition 1.1.1** A natural number n is in S if and only if $ n = 0 or n - 3 ∈ S $ .

> 定义1.1.1 :  一个自然数 n, 当且仅当 n = 0 或者 n - 3 ∈ S 的时候， n 在 S 集合中。


Let us see how we can use this definition to determine what natural numbers are in S. We know that 0 ∈ S. Therefore 3 ∈ S, since (3 - 3) = 0 and 0 ∈ S. Similarly 6 ∈ S, since (6 - 3) = 3 and 3 ∈ S. Continuing in this way, we can conclude that all multiples of 3 are in S.

> 让我们看看如何使用这个定义来确定 S 中的自然数。我们知道 0 ∈ S，因此 3 ∈ S，因为 (3-3) = 0 且 0 ∈ S，同样 6 ∈ S，因为 (6-3) = 3 和 3 ∈ S. 以这种方式继续下去，我们可以得出所有3的倍数都在 S 中。


What about other natural numbers? Is 1 ∈ S? We know that 1 != 0, so the first condition is not satisfied. Furthermore, (1 - 3) = -2, which is not a natural number and thus is not a member of S. Therefore the second condition is not satisfied. Since 1 satisfies neither condition, 1 ∉ S . Similarly, 2 ∉ S. What about 4? 4 ∈ S only if 1 ∈ S. But 1 ∉ S, so 4 ∉ S, as well. Similarly, we can conclude that if n is a natural number and is not a multiple of 3, then n ∉ S.

> 其他自然数呢？1 ∈ S 吗？我们知道 1 != 0，所以第一个条件不满足。再者，(1-3) = -2，它不是一个自然数，所以也不是 S 的成员，因此不满足第二个条件。由于1两个条件都不满足，所以 1 ∉ S。同样，2 ∉ S。那么4呢？4 ∈ S 仅当 1 ∈ S，但是 1 ∉ S，所以4 ∉ S 。同样，我们可以得出结论，如果 n 是一个自然数，而不是3的倍数，那么 n ∉ S。


From this argument, we conclude that S is the set of natural numbers that are multiples of 3.

> 根据这个论证，我们得出 S 是3的倍数的自然数的集合。


We can use this definition to write a procedure to decide whether a natural number n is in S.

> 我们可以使用这个定义编写一个程序来判断一个自然数 n 是否在 S 中。


```rkt
in-S? : N → Bool
usage: (in-S? n) = #t if n is in S, #f otherwise

(define in-S?
    (lambda (n)
        (if (zero? n) #t
            (if (>= (- n 3) 0)
                (in-S? (- n 3))
                #f))))
```

Here we have written a recursive procedure in Scheme that follows the definition. The notation `in-S? : N → Bool` is a comment, called the contract for this procedure. It means that in-S? is intended to be a procedure that takes a natural number and produces a boolean. Such comments are helpful for reading and writing code.

> 此处，我们根据定义用Scheme编写了一个递归程序。符号  `in-S: N → Bool` 是一个注释，称为这个程序的协定(契约)。它意味着 `in-S?` 是一个接受自然数并生成布尔值的程序。 这样的注释有助于阅读和编写代码。


To determine whether n ∈ S, we first ask whether n = 0. If it is, then the answer is true. Otherwise we need to see whether n - 3 ∈ S. To do this, we  first check to see whether (n - 3) >= 0. If it is, we then can use our procedure to see whether it is in S. If it is not, then n cannot be in S.

> 为了确定是否 n ∈ S，我们首先判断是否 n = 0。如果是这样，那么答案就是正确的。否则，我们需要看看 n - 3 是否属于S，为了做到这一点，我们首先检查是否 (n -3) >= 0。如果是，那么可以使用我们的程序来检查它是否在 S 中。如果不是，那么 n 就不在 S 中。


Here is an alternative way of writing down the definition of S.

> 这里有另一种定义 S 的方法。


**Definition 1.1.2** Define the set S to be the smallest set contained in N and satisfying the following two properties:

    1. 0 ∈ S, and
    2. if n ∈ S, then n + 3 ∈ S.

> 定义 1.1.2 : 将集合 S 定义为 N 中包含的最小集合，并满足以下两个特性:
>
> 1. 0 ∈ S
>
> 2. 如果 n ∈ S， 那么 n + 3 ∈ S


A “smallest set” is the one that satisfies properties 1 and 2 and that is a subset of any other set satisfying properties 1 and 2. It is easy to see that there can be only one such set: if S1 and S2 both satisfy properties 1 and 2, and both are smallest, then S1 ⊆ S2 (since S1 is smallest), and S2 ⊆ S1 (since S2 is smallest), hence S1 = S2. We need this extra condition, because otherwise there are many sets that satisfy the remaining two conditions (see exercise 1.3).

> “最小集”是指满足属性1和属性2的集合，是其他任何满足属性1和属性2的集合的子集。很容易看出，只有一个这样的集合: 如果S1 和 S2都满足属性1和2，并且都是最小的，那么 S1 ⊆ S2(因为 S1是最小的) ，S2 ⊆ S1(因为 S2是最小的) ，因此 S1 = S2。我们需要这个额外的条件，因为除此之外还有许多集满足其余两个条件(参见练习1.3)。


Here is yet another way of writing the definition:

> 还有另外的一种定义的编写方式:

```
 -------
  0 ∈ S


  n ∈ S
----------
(n+3) ∈ S
```


This is simply a shorthand notation for the preceding version of the definition. Each entry is called *a rule of inference*, or just a *rule*; the horizontal line is read as an “if-then.” The part above the line is called the *hypothesis* or the *antecedent*; the part below the line is called the *conclusion* or the *consequent*. When there are two or more hypotheses listed, they are connected by an implicit “and” (see definition 1.1.5). A rule with no hypotheses is called an axiom. We often write an axiom without the horizontal line, like `0 ∈ S`.

> 这只是之前定义的简写符号。每个条目被称为一个推理规则，或者仅仅是一个规则; 水平线被解读为一个 "if-then" 结构. 线以上的部分称为 假设(前提/假定) 或 前件(前项); 线以下的部分称为 结论(结果) 或 后件(后项)。当有两个或两个以上的假设被列出时，它们通过一个隐含的 "and (逻辑与)" (见定义1.1.5)连接起来。没有假设的规则称为公理。我们经常写一个省略横线的公理(公设)，比如 `0 ∈ S`。


The rules are interpreted as saying that a natural number n is in S if and only if the statement `n ∈ S` can be derived from the axioms by using the rules of inference finitely many times. This interpretation automatically makes S the smallest set that is closed under the rules.

> 这些规则被解释为 一个自然数 n 属于 S， 当且仅当 n ∈ S 可以通过有限次推理规则从公理推导出。这种解释自动使 S 成为在规则下闭合的最小集合。


These definitions all say the same thing. We call the first version a *top-down* definition, the second version a *bottom-up* definition, and the third version a *rules-of-inference* version.

> 这些定义都表达了同样的意思。我们称第一个版本为自顶向下的定义，第二个版本为自底向上的定义，第三个版本为推理规则版本。


Let us see how this works on some other examples.

> 让我们看看这些定义在其他一些例子上是如何工作的.




