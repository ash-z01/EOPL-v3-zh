## 1.1 Recursively Specified Data

> 递归规范数据


When writing code for a procedure, we must know precisely what kinds of values may occur as arguments to the procedure, and what kinds of values are legal for the procedure to return. Often these sets of values are complex. In this section we introduce formal techniques for specifying sets of values.

> 在编写过程代码时，我们必须准确地知道哪些类型的值可能作为过程的参数出现，以及返回哪些类型的值是合法的。通常这些值集是复杂的。在本节中，我们将介绍用于规范值集的形式化技术。


### 1.1.1 Inductive Specification

> 归纳规范


*Inductive specification* is a powerful method of specifying a set of values. To illustrate this method, we use it to describe a certain subset S of the natural numbers $N = {0, 1, 2, ... }.$

> 归纳规范是规范一组值集的强大方法。为了说明这个方法，我们用它来描述自然数 $N = {0,1,2,... }$ 的某个子集 S 。


**Definition 1.1.1** A natural number n is in S if and only if $ n = 0 or n - 3 ∈ S $ .

> 定义1.1.1 :  一个自然数 n, 当且仅当 n = 0 或者 n - 3 ∈ S 的时候， n 在 S 集合中。


Let us see how we can use this definition to determine what natural numbers are in S. We know that 0 ∈ S. Therefore 3 ∈ S, since (3 - 3) = 0 and 0 ∈ S. Similarly 6 ∈ S, since (6 - 3) = 3 and 3 ∈ S. Continuing in this way, we can conclude that all multiples of 3 are in S.

> 让我们看看如何使用这个定义来确定 S 中的自然数。我们知道 0 ∈ S，因此 3 ∈ S，因为 (3-3) = 0 且 0 ∈ S，同样 6 ∈ S，因为 (6-3) = 3 和 3 ∈ S. 以这种方式继续下去，我们可以得出所有3的倍数都在 S 中。


What about other natural numbers? Is 1 ∈ S? We know that 1 != 0, so the first condition is not satisfied. Furthermore, (1 - 3) = -2, which is not a natural number and thus is not a member of S. Therefore the second condition is not satisfied. Since 1 satisfies neither condition, 1 ∉ S . Similarly, 2 ∉ S. What about 4? 4 ∈ S only if 1 ∈ S. But 1 ∉ S, so 4 ∉ S, as well. Similarly, we can conclude that if n is a natural number and is not a multiple of 3, then n ∉ S.

> 其他自然数呢？1 ∈ S 吗？我们知道 1 != 0，所以第一个条件不满足。再者，(1-3) = -2，它不是一个自然数，所以也不是 S 的成员，因此不满足第二个条件。由于1两个条件都不满足，所以 1 ∉ S。同样，2 ∉ S。那么4呢？4 ∈ S 仅当 1 ∈ S，但是 1 ∉ S，所以4 ∉ S 。同样，我们可以得出结论，如果 n 是一个自然数，而不是3的倍数，那么 n ∉ S。


From this argument, we conclude that S is the set of natural numbers that are multiples of 3.

> 根据这个论证，我们得出 S 是3的倍数的自然数的集合。


We can use this definition to write a procedure to decide whether a natural number n is in S.

> 我们可以使用这个定义编写一个程序来判断一个自然数 n 是否在 S 中。


```rkt
in-S? : N → Bool
usage: (in-S? n) = #t if n is in S, #f otherwise

(define in-S?
    (lambda (n)
        (if (zero? n) #t
            (if (>= (- n 3) 0)
                (in-S? (- n 3))
                #f))))
```

Here we have written a recursive procedure in Scheme that follows the definition. The notation `in-S? : N → Bool` is a comment, called the contract for this procedure. It means that in-S? is intended to be a procedure that takes a natural number and produces a boolean. Such comments are helpful for reading and writing code.

> 此处，我们根据定义用Scheme编写了一个递归程序。符号  `in-S: N → Bool` 是一个注释，称为这个程序的协定(契约)。它意味着 `in-S?` 是一个接受自然数并生成布尔值的程序。 这样的注释有助于阅读和编写代码。


To determine whether n ∈ S, we first ask whether n = 0. If it is, then the answer is true. Otherwise we need to see whether n - 3 ∈ S. To do this, we  first check to see whether (n - 3) >= 0. If it is, we then can use our procedure to see whether it is in S. If it is not, then n cannot be in S.

> 为了确定是否 n ∈ S，我们首先判断是否 n = 0。如果是这样，那么答案就是正确的。否则，我们需要看看 n - 3 是否属于S，为了做到这一点，我们首先检查是否 (n -3) >= 0。如果是，那么可以使用我们的程序来检查它是否在 S 中。如果不是，那么 n 就不在 S 中。


Here is an alternative way of writing down the definition of S.

> 这里有另一种定义 S 的方法。


**Definition 1.1.2** Define the set S to be the smallest set contained in N and satisfying the following two properties:

    1. 0 ∈ S, and
    2. if n ∈ S, then n + 3 ∈ S.

> 定义 1.1.2 : 将集合 S 定义为 N 中包含的最小集合，并满足以下两个特性:
>
> 1. 0 ∈ S
>
> 2. 如果 n ∈ S， 那么 n + 3 ∈ S


A “smallest set” is the one that satisfies properties 1 and 2 and that is a subset of any other set satisfying properties 1 and 2. It is easy to see that there can be only one such set: if S1 and S2 both satisfy properties 1 and 2, and both are smallest, then S1 ⊆ S2 (since S1 is smallest), and S2 ⊆ S1 (since S2 is smallest), hence S1 = S2. We need this extra condition, because otherwise there are many sets that satisfy the remaining two conditions (see exercise 1.3).

> “最小集”是指满足属性1和属性2的集合，是其他任何满足属性1和属性2的集合的子集。很容易看出，只有一个这样的集合: 如果S1 和 S2都满足属性1和2，并且都是最小的，那么 S1 ⊆ S2(因为 S1是最小的) ，S2 ⊆ S1(因为 S2是最小的) ，因此 S1 = S2。我们需要这个额外的条件，因为除此之外还有许多集满足其余两个条件(参见练习1.3)。


Here is yet another way of writing the definition:

> 还有另外的一种定义的编写方式:

```
 -------
  0 ∈ S


  n ∈ S
----------
(n+3) ∈ S
```


This is simply a shorthand notation for the preceding version of the definition. Each entry is called *a rule of inference*, or just a *rule*; the horizontal line is read as an “if-then.” The part above the line is called the *hypothesis* or the *antecedent*; the part below the line is called the *conclusion* or the *consequent*. When there are two or more hypotheses listed, they are connected by an implicit “and” (see definition 1.1.5). A rule with no hypotheses is called an axiom. We often write an axiom without the horizontal line, like `0 ∈ S`.

> 这只是之前定义的简写符号。每个条目被称为一个推理规则，或者仅仅是一个规则; 水平线被解读为一个 "if-then" 结构. 线以上的部分称为 假设(前提/假定) 或 前件(前项); 线以下的部分称为 结论(结果) 或 后件(后项)。当有两个或两个以上的假设被列出时，它们通过一个隐含的 "and (逻辑与)" (见定义1.1.5)连接起来。没有假设的规则称为公理。我们经常写一个省略横线的公理(公设)，比如 `0 ∈ S`。


The rules are interpreted as saying that a natural number n is in S if and only if the statement `n ∈ S` can be derived from the axioms by using the rules of inference finitely many times. This interpretation automatically makes S the smallest set that is closed under the rules.

> 这些规则被解释为 一个自然数 n 属于 S， 当且仅当 n ∈ S 可以通过有限次推理规则从公理推导出。这种解释自动使 S 成为在规则下闭合的最小集合。


These definitions all say the same thing. We call the first version a *top-down* definition, the second version a *bottom-up* definition, and the third version a *rules-of-inference* version.

> 这些定义都表达了同样的意思。我们称第一个版本为自顶向下的定义，第二个版本为自底向上的定义，第三个版本为推理规则版本。


Let us see how this works on some other examples.

> 让我们看看这些定义在其他一些例子上是如何工作的.


**Definition 1.1.3 (list of integers, top-down)** A Scheme list is a list of integers if and only if either:

    1. it is the empty list, or
    2. it is a pair whose car is an integer and whose cdr is a list of integers.

> 定义 1.1.3 (整数列表，自顶向下) : 一个 Scheme 列表是一个整数列表当且仅当:
>
> 1. 它是空列表，或者
> 2. 它是一个整数对，其 car 是一个整数，其 cdr 是一个整数列表。

> 译注: car, cdr 是 scheme语言中 两个重要的操作(函数), 分别是取列表中第一个元素，和剩下的元素.

```rkt
(car (list 1 2 3)) => 1
(cdr (list 1 2 3)) => '(2 3)
(cdr '(1 2))       => '(2)
(cdr '(1 . 2))     => 2
```


We use *Int* to denote the set of all integers, and *List-of-Int* to denote the set of lists of integers.

> 我们使用 Int 表示所有整数的集合，list-of-Int 表示整数列表的集合。


**Definition 1.1.4 (list of integers, bottom-up)** The set List-of-Int is the smallest set of Scheme lists satisfying the following two properties:

    1. () ∈ List-of-Int, and
    2. if n ∈ Int and l ∈ List-of-Int, then (n . l) ∈ List-of-Int.

> 定义 1.1.4 (整数列表，自底向上) : 集合List-of-Int 是满足以下两个属性的 Scheme 列表的最小集合
>
> 1. () ∈ List-of-Int，并且
> 2. 如果 n ∈ Int，l ∈ Int List-of-Int，则 (n. l) ∈ List-of-Int。


Here we use the infix "." to denote the result of the *cons* operation in Scheme. The phrase (n . l) denotes a Scheme pair whose car is n and whose cdr is l.

> 这里，我们使用中缀符号 `.` 来表示Scheme中 cons 操作的结果. 短语 (n . l) 表示一个Scheme序对，这个序对的car是n, cdr是l。


Definition 1.1.5 (list of integers, rules of inference)

```
() ∈ List-of-Int



n ∈ Int    l ∈ List-of-Int
-----------------------------
(n . l) ∈ List-of-Int
```


> 定义 1.1.5 (整数列表，推理规则)


These three definitions are equivalent. We can show how to use them to generate some elements of List-of-Int.

> 这三个定义是等价的，我们可以演示如何使用它们来生成 List-of-Int 的某些元素。


1. *()* is a list of integers, because of property 1 of definition 1.1.4 or the first rule of definition 1.1.5.

> 1. `()` 是一个整数列表，因为根据定义1.1.4的特性1 或者 根据 定义1.1.5的规则，就能得出.


2. *(14 . ())* is a list of integers, because of property 2 of definition 1.1.4, since *14* is an integer and *()* is a list of integers. We can also write this as an instance of the second rule for List-of-Int.

> `(14 . ())` 是一个整数列表，可由定义1.1.4的特性2得出，因为`14`是一个整数，而`()`是一个整数列表。我们还可以将其编写为 List-of-Int 的第二条规则的实例。

```
14 ∈ Int     () ∈ List-of-Int
-------------------------------
(14 . ()) ∈ List-of-Int
```


3. *(3 . (14 . ()))* is a list of integers, because of property 2, since 3 is an integer and *(14 . ())* is a list of integers. We can write this as another instance of the second rule for List-of-Int.

> `(3. (14 . ())` 是一个整数列表，根据上文第2点和1.1.4的特性2，由于`3`是一个整数 并且 `(14 . ())` 是一个整数列表。我们可以将其编写为 List-of-Int 第二条规则的另一个实例。

```
3 ∈ Int      (14 . ()) ∈ List-of-Int
---------------------------------------
(3 . (14 . ())) ∈ List-of-Int
```


4. *(-7 . (3 . (14 . ())))* is a list of integers, because of property 2, since *-7* is a integer and *(3 . (14 . ()))* is a list of integers. Once more we can write this as an instance of the second rule for List-of-Int.

> `(-7 . (3 . (14 . ()))` 是一个整数列表，根据上文第3点和1.1.4的特性2，因为`-7`是一个整数 且 `(3 . (14 . ())` 是一个整数列表。我们可以再次将其作为 List-of-Int 的第二条规则的实例来编写。

```
-7 ∈ Int        (3 . (14 . ())) ∈ List-of-Int
------------------------------------------------
(-7 . (3 . (14 . ()))) ∈ List-of-Int
```


5. Nothing is a list of integers unless it is built in this fashion.

> 除非以这种方式构建出来，否则就不是整数列表。


Converting from dot notation to list notation, we see that (), (14), (3 14), and (-7 3 14) are all members of List-of-Int.

> 从点符号到列表符号的转换，我们看到()、(14)、(3 14)和(-7 3 14)都是 List-of-Int 的成员。


We can also combine the rules to get a picture of the entire chain of reasoning that shows that (-7 . (3 . (14 . ()))) ∈ List-of-Int. The tree-like picture below is called a derivation or deduction tree.

> 我们也可以将这些规则结合起来，得到整个推理图，它显示 (-7 . (3 . (14 . ())) ∈ List-of-Int。下方的树状图 称为 派生树或演绎树。

```
                   14 ∈ N    () ∈ List-of-Int
                  ---------------------------
           3 ∈ N    (14 . ()) ∈ List-of-Int
          -----------------------------------
-7 ∈ N     (3 . (14 . ())) ∈ List-of-Int
---------------------------------------------
(-7 . (3 . (14 . ()))) ∈ List-of-Int
```


Exercise 1.1 [*] Write inductive definitions of the following sets. Write each definition in all three styles (top-down, bottom-up, and rules of inference). Using your rules, show the derivation of some sample elements of each set.

1. {3n + 2 |n ∈ N}
2. {2n + 3m + 1 |n, m ∈ N}
3. {(n, 2n + 1) |n ∈ N}
4. {(n, n^2) |n ∈ N}

Do not mention squaring in your rules. As a hint, remember the equation (n + 1)^2 = n^2 + 2n + 1.

> 练习 1.1 [*] 写出下列集合的归纳定义。用所有三种风格(自顶向下、自底向上和推理规则)编写每个定义。使用您的规则，描述每个集合的一些示例元素。
>
> PS: 不要在你的规则中提到平方. 提示一下，记住这个等式 `(n + 1)^2 = n^2 + 2n + 1` 。


Exercise 1.2 [* *] What sets are defined by the following pairs of rules? Explain why.

1. 
```
(0, 1) ∈ S 


   (n, k) ∈ S
-------------------
(n + 1, k + 7) ∈ S
```

2. 
```
(0, 1) ∈ S 


   (n, k) ∈ S
-------------------
(n + 1, 2k) ∈ S
```

3.
```
(0, 0, 1) ∈ S 


   (n, i, j) ∈ S
-------------------
(n + 1, j, i + j) ∈ S
```

4. [* * *]
```
(0, 1, 0) ∈ S 


   (n, i, j) ∈ S
-------------------
(n + 1, i + 2, i + j) ∈ S
```

> 练习 1.2 [* *] 什么样的集合是由以下几对规则定义的? 请解释原因。


Exercise 1.3 [*] Find a set T of natural numbers such that 0 ∈ T, and whenever n ∈ T, then n + 3 ∈ T, but T ∉ S, where S is the set defined in definition 1.1.2.

> 练习 1.3 [*] 找出一个自然数集T，使得 0 ∈ T，并且当 n ∈ T 时，n + 3 ∈ T，但 T ∉ S，其中 S 是定义1.1.2中定义的集合。


